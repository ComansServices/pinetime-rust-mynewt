<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Bluetooth Time Sync, Rust Watch Faces and LVGL on PineTime Mynewt</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Bluetooth Time Sync, Rust Watch Faces and LVGL on PineTime Mynewt" 
    data-rh="true">
<meta property="og:description" 
    content="How PineTime syncs the time over Bluetooth LE... And how we build PineTime Watch Faces with Rust and LVGL" 
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/timesync-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Bluetooth Time Sync, Rust Watch Faces and LVGL on PineTime Mynewt</h1>
    <nav id="TOC"><ul>
<li><a href="#time-sync-over-bluetooth-le">1 Time Sync over Bluetooth LE</a><ul></ul></li>
<li><a href="#discover-gatt-services-and-characteristics">2 Discover GATT Services and Characteristics</a><ul></ul></li>
<li><a href="#read-gatt-characteristic-for-current-time">3 Read GATT Characteristic for Current Time</a><ul></ul></li>
<li><a href="#set-system-time">4 Set System Time</a><ul></ul></li>
<li><a href="#bluetooth-log-for-time-sync">5 Bluetooth Log for Time Sync</a><ul></ul></li>
<li><a href="#get-the-time-in-c">6 Get the Time in C</a><ul></ul></li>
<li><a href="#get-the-time-in-rust">7 Get the Time in Rust</a><ul></ul></li>
<li><a href="#watch-face-in-c">8 Watch Face in C</a><ul></ul></li>
<li><a href="#watch-face-in-rust">9 Watch Face in Rust</a><ul></ul></li>
<li><a href="#porting-lvgl-to-mynewt">10 Porting LVGL to Mynewt</a><ul></ul></li>
<li><a href="#rust-wrapper-for-lvgl">11 Rust Wrapper for LVGL</a><ul></ul></li>
<li><a href="#whats-next">12 What's Next</a><ul></ul></li></ul></nav><p><img src="https://lupyuen.github.io/images/timesync-title.png" alt="PineTime Smart Watch with Bluetooth Time Sync and Rust Watch Face" /></p>
<p>Let's learn how PineTime syncs the time over Bluetooth LE... And how we build PineTime Watch Faces with Rust and LVGL.</p>
<h1 id="time-sync-over-bluetooth-le" class="section-header"><a href="#time-sync-over-bluetooth-le">1 Time Sync over Bluetooth LE</a></h1>
<p>Try this on your Android phone...</p>
<ol>
<li>
<p>Install the <strong>nRF Connect</strong> mobile app. Launch the app.</p>
</li>
<li>
<p>Tap on <code>Menu</code> → <code>Configure GATT Server</code> → <code>Add Service</code></p>
</li>
<li>
<p>Set <code>Server Configuration</code> to <code>Current Time Service</code>. Tap <code>OK</code></p>
</li>
<li>
<p>In the app, browse for Bluetooth devices and connect to PineTime</p>
</li>
</ol>
<p>The current date and time appears on PineTime!</p>
<p><em>What is this magic that syncs the date the time from your phone to PineTime?</em></p>
<p>The syncing magic is called <strong>Bluetooth LE Current Time Service</strong>...</p>
<p><img src="https://lupyuen.github.io/images/timesync-gatt.jpg" alt="Bluetooth Time Sync" /></p>
<ol>
<li>
<p>Our phone connects to PineTime over Bluetooth LE</p>
</li>
<li>
<p>PineTime detects the incoming connection. </p>
<p>PineTime transmits a request to discover all GATT Services and Characteristics on our phone.</p>
<p>(Like a &quot;reverse snoop&quot;)</p>
</li>
<li>
<p>PineTime discovers that our phone supports the Current Time Service. </p>
<p>PineTime transmits a request to read the current time. </p>
<p>The nRF Connect app on our phone responds with the current time.</p>
</li>
</ol>
<p><em>Is it really necessary to discover ALL GATT Services and Characteristics?</em></p>
<p>Not really... It's actually more efficient for PineTime to connect directly to the Current Time Service without discovering all services.</p>
<p>But for now we'll discover all services as an educational exercise... Also to allow for future extension in case we need to support more services.</p>
<p>Let's learn how to discover GATT Services and Characteristics in the <code>pinetime-rust-mynewt</code> firmware for PineTime...</p>
<h1 id="discover-gatt-services-and-characteristics" class="section-header"><a href="#discover-gatt-services-and-characteristics">2 Discover GATT Services and Characteristics</a></h1>
<p>First step in our Time Sync magic... Detect incoming Bluetooth LE connections.</p>
<p>We're using the open-source NimBLE Bluetooth LE stack, which exposes a hook for us to detect incoming connections: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L368-L416"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">//  The NimBLE stack executes this callback function when a GAP Event occurs
static int bleprph_gap_event(struct ble_gap_event *event, void *arg) {
    //  Check the GAP Event
    switch (event-&gt;type) {

        //  When a BLE connection is established...
        case BLE_GAP_EVENT_CONNECT:

            //  Remember the BLE Peer
            blepeer_add(
                event-&gt;connect.conn_handle  //  BLE Connection
            );

            //  Discover all GATT Sevices and Characteristics in the BLE Peer
            blepeer_disc_all(
                event-&gt;connect.conn_handle,  //  BLE Connection
                blecent_on_disc_complete,    //  Callback function that will be called when discovery is complete
                NULL                         //  No argument for callback
            );
</code></pre>
<p>When we see an incoming Bluetooth LE connection, we react by remembering the peer-to-peer connection with <code>blepeer_add</code>. </p>
<p>Then we discover all GATT Services and Characteristics of our peer (mobile phone) by calling <code>blepeer_disc_all</code>.</p>
<p>Here's the callback function that's called when the GATT Services and Characteristics have been discovered: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L88-L107"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">/// Called when GATT Service Discovery of the BLE Peer has completed
static void blecent_on_disc_complete(const struct blepeer *peer, int status, void *arg) {
    //  Omitted: Check that discovery status is successful

    //  GATT Service Discovery has completed successfully.
    //  Now we have a complete list of services, characteristics 
    //  and descriptors that the peer supports.

    //  Read the GATT Characteristics from the peer
    blecent_read(peer);
}
</code></pre>
<p>Now we can call <code>blecent_read</code> to read the Current Time Characteristic exposed to PineTime by our phone. We'll learn how in the next section.</p>
<p><em>What are <code>blepeer_add</code> and <code>blepeer_disc_all</code>?</em></p>
<p>They are <strong>Bluetooth LE Peer Functions</strong> provided by NimBLE to maintain peer-to-peer Bluetooth LE connections and to remember the discovered GATT Services and Characteristics.</p>
<p>See <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_peer.h"><code>apps/my_sensor_app/src/ble_peer.h</code></a> and <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_peer.c"><code>ble_peer.c</code></a> </p>
<h1 id="read-gatt-characteristic-for-current-time" class="section-header"><a href="#read-gatt-characteristic-for-current-time">3 Read GATT Characteristic for Current Time</a></h1>
<p>Our Time Sync story so far...</p>
<ol>
<li>
<p>PineTime has detected an incoming Bluetooth LE connection from our mobile phone</p>
</li>
<li>
<p>PineTime reacts by discovering all GATT Services and Characteristics exposed by our phone (through the nRF Connect mobile app)</p>
</li>
<li>
<p>PineTime is now ready to read the Current Time Characteristic exposed by our phone</p>
</li>
</ol>
<p>Here's how we read the Current Time Characteristic with NimBLE: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L109-L139"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">/// Read the GATT Characteristic for Current Time from the BLE Peer
static void blecent_read(const struct blepeer *peer) {
    //  Find the GATT Characteristic for Current Time Service from the discovered GATT Characteristics
    const struct blepeer_chr *chr = blepeer_chr_find_uuid(
        peer,
        BLE_UUID16_DECLARE( BLE_GATT_SVC_CTS ),      //  GATT Service for Current Time Service
        BLE_UUID16_DECLARE( BLE_GATT_CHR_CUR_TIME )  //  GATT Characteristic for Current Time Service
    );

    //  Omitted: Check that the Current Time Characteristic exists

    //  Read the Current Time Characteristic
    ble_gattc_read(
        peer-&gt;conn_handle,      //  BLE Connection
        chr-&gt;chr.val_handle,    //  GATT Characteristic
        blecent_on_read,        //  Callback function that will be called when reading is complete
        NULL                    //  No argument for callback
    );
}
</code></pre>
<p><code>ble_gattc_read</code> is the function provided by NimBLE to transmit a Bluetooth LE request to read a GATT Characteristic (the Current Time Characteristic).</p>
<p>The Current Time Service and Current Time Characteristic are defined in the Bluetooth Specifications...</p>
<pre><code class="language-c">#define BLE_GATT_SVC_CTS        (0x1805)  //  GATT Service for Current Time Service
#define BLE_GATT_CHR_CUR_TIME   (0x2A2B)  //  GATT Characteristic for Current Time
</code></pre>
<p>The Current Time Characteristic returns the current date and time in this 10-byte format: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L75-L86"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">/// Data Format for Current Time Service. Based on https://github.com/sdalu/mynewt-nimble/blob/495ff291a15306787859a2fe8f2cc8765b546e02/nimble/host/services/cts/src/ble_svc_cts.c
struct ble_current_time {
    uint16_t year;
    uint8_t  month;
    uint8_t  day;
    uint8_t  hours;
    uint8_t  minutes;
    uint8_t  seconds;
    uint8_t  day_of_week;  //  From 1 (Monday) to 7 (Sunday)
    uint8_t  fraction256;
    uint8_t  adjust_reason;
} __attribute__((__packed__));
</code></pre>
<p>So when our phone returns these 10 bytes to PineTime as the current date/time...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">e4</span> <span class="number">07</span> <span class="number">0a</span> <span class="number">04</span> <span class="number">0e</span> <span class="number">05</span> <span class="number">29</span> <span class="number">07</span> <span class="number">87</span> <span class="number">00</span> </pre></div>
<p>PineTime shall decode the 10 bytes as...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="number">2020</span><span class="op">-</span><span class="number">10</span><span class="op">-</span><span class="number">04</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">41.527343</span> <span class="ident">Sunday</span></pre></div>
<p>We'll see in a while how PineTime decodes the 10 bytes and sets the Mynewt system time.</p>
<h1 id="set-system-time" class="section-header"><a href="#set-system-time">4 Set System Time</a></h1>
<p>One fine Sunday afternoon in sunny Singapore, the 4th of October 2020, at 2:05 PM (and 41.527343 seconds), PineTime received these 10 encoded bytes...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">e4</span> <span class="number">07</span> <span class="number">0a</span> <span class="number">04</span> <span class="number">0e</span> <span class="number">05</span> <span class="number">29</span> <span class="number">07</span> <span class="number">87</span> <span class="number">00</span> </pre></div>
<p>That's the Encoded Current Time, in Bluetooth LE format, returned by our phone (with nRF Connect) to PineTime. The NimBLE Bluetooth LE Stack passes these 10 bytes to our firmware in the <strong>Mbuf Format.</strong></p>
<p><em>What's an Mbuf?</em></p>
<p>An <a href="https://mynewt.apache.org/latest/os/core_os/mbuf/mbuf.html">Mbuf (Memory Buffer)</a> is a linked list of fixed-size blocks thats uses RAM efficiently for networking tasks, like Bluetooth LE.</p>
<p>To work with the data inside the Mbuf linked list, we need to &quot;flatten&quot; the Mbuf (like <code>om</code>) into an array or struct (like <code>current_time</code>)...</p>
<pre><code class="language-c">//  Get the Mbuf size
uint16_t om_len = OS_MBUF_PKTLEN(om);

//  Allocate storage for the BLE Current Time
struct ble_current_time current_time;

//  Copy the data from the Mbuf to the BLE Current Time
ble_hs_mbuf_to_flat(  //  Flatten and copy the Mbuf...
    om,               //  From om...
    &amp;current_time,    //  To current_time...
    om_len,           //  For om_len bytes
    NULL
);
</code></pre>
<p>Here's how we use the Mbuf data to decode the Current Time: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L141-L235"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">/// Called when Current Time GATT Characteristic has been read
static int blecent_on_read(uint16_t conn_handle, const struct ble_gatt_error *error, struct ble_gatt_attr *attr, void *arg) {
    //  Set the system time from the received time in Mbuf format
    set_system_time(attr-&gt;om);
    return 0;
}

/// Set system time given the BLE Current Time in Mbuf format. Based on https://github.com/sdalu/mynewt-nimble/blob/495ff291a15306787859a2fe8f2cc8765b546e02/nimble/host/services/cts/src/ble_svc_cts.c
static int set_system_time(const struct os_mbuf *om) {
    //  Get the Mbuf size
    uint16_t om_len = OS_MBUF_PKTLEN(om);

    //  Allocate storage for the BLE Current Time
    struct ble_current_time current_time;

    //  Copy the data from the Mbuf to the BLE Current Time
    ble_hs_mbuf_to_flat(  //  Flatten and copy the Mbuf...
        om,               //  From om...
		&amp;current_time,    //  To current_time...
        om_len,           //  For om_len bytes
        NULL
    );

    //  Convert BLE Current Time to clocktime format
    struct clocktime ct;
    ct.year = le16toh(current_time.year);
    ct.mon  = current_time.month;
    ct.day  = current_time.day;
    ct.hour = current_time.hours;
    ct.min  = current_time.minutes;
    ct.sec  = current_time.seconds;
    ct.usec = (current_time.fraction256 * 1000000) / 256;
</code></pre>
<p>We have just populated a <code>clocktime</code> struct <code>ct</code> with the decoded date and time values.</p>
<p>Now we fetch the default timezone <code>tz</code> from Mynewt (because it's needed later for setting the time)...</p>
<pre><code class="language-c">    //  Get the timezone, which will used for clocktime conversion
    struct os_timeval tv0;
    struct os_timezone tz;
    os_gettimeofday(&amp;tv0, &amp;tz);
</code></pre>
<p>Mynewt only accepts system time in the <code>timeval</code> format, so we convert it here (passing the timezone)...</p>
<pre><code class="language-c">    //  Convert clocktime format to timeval format, passing the timezone
    struct os_timeval tv;    
    clocktime_to_timeval(&amp;ct, &amp;tz, &amp;tv);
</code></pre>
<p>Finally we call the Mynewt Function <code>os_settimeofday</code> to set the system time.</p>
<pre><code class="language-c">    //  Set the system time in timeval format
    os_settimeofday(&amp;tv, NULL);
</code></pre>
<p>And that's how we sync the time from our mobile phone to PineTime!</p>
<h1 id="bluetooth-log-for-time-sync" class="section-header"><a href="#bluetooth-log-for-time-sync">5 Bluetooth Log for Time Sync</a></h1>
<p>When we perform Time Sync over Bluetooth LE, we'll see these debugging messages emitted by PineTime: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L246-L259"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<table><thead><tr><th align="left">Debug Message</th><th align="left">Remark</th></tr></thead><tbody>
<tr><td align="left"><code>Starting BLE...</code></td><td align="left">Start the NimBLE Bluetooth LE Stack</td></tr>
<tr><td align="left"><code>BLE started</code></td><td align="left"></td></tr>
<tr><td align="left"><code>Render LVGL display...</code><br><code>Flush display: </code><br><code>left=63, top=27, right=196, bottom=42...</code></td><td align="left">Render the initial watch face</td></tr>
<tr><td align="left"><code>connection established</code></td><td align="left">Mobile phone connects to PineTime</td></tr>
<tr><td align="left"><code>connection updated </code></td><td align="left"></td></tr>
<tr><td align="left"><code>Service discovery complete; </code><br><code>status=0 conn_handle=1</code></td><td align="left">PineTime discovers the Current Time Service</td></tr>
<tr><td align="left"><code>Read complete; </code><br><code>status=0 conn_handle=1 attr_handle=67</code><br><code>value=e4 07 0a 04 0e 05 29 07 87 00 </code></td><td align="left">PineTime reads and receives the <br> 10-byte current time</td></tr>
<tr><td align="left"><code>Current Time: </code><br><code>2020-10-04T14:05:41.527343+00:00</code></td><td align="left">PineTime decodes the current time</td></tr>
<tr><td align="left">...</td><td align="left"></td></tr>
<tr><td align="left"><code>Render LVGL display...</code><br><code>Flush display: </code><br><code>left=60, top=27, right=183, bottom=42...</code></td><td align="left">Render the updated watch face</td></tr>
<tr><td align="left">...</td><td align="left"></td></tr>
<tr><td align="left"><code>Render LVGL display...</code><br><code>Flush display: </code><br><code>left=59, top=27, right=181, bottom=42...</code></td><td align="left">Render the updates every minute</td></tr>
</tbody></table>
<p>We'll learn about Watch Faces in a while.</p>
<p>Before that, let's find out how to read the Mynewt system time in C and in Rust.</p>
<h1 id="get-the-time-in-c" class="section-header"><a href="#get-the-time-in-c">6 Get the Time in C</a></h1>
<p>Here's how we fetch the Mynewt system time in C for building Watch Faces: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/watch_face.c#L65-L82"><code>my_sensor_app/src/watch_face.c</code></a></p>
<pre><code class="language-c">//  Get the system time in timeval format
struct os_timeval tv;
struct os_timezone tz;
int rc = os_gettimeofday(&amp;tv, &amp;tz);
if (rc != 0) { console_printf(&quot;Can't get time: %d\n&quot;, rc); return 2; }
</code></pre>
<p>This produces a <a href="http://mynewt.apache.org/v1_7_0/os/core_os/time/os_time.html"><code>timeval</code> struct</a> in <code>tv</code> that indicates the number of microseconds elapsed since Jan 1 1970.</p>
<p>Which isn't really meaningful for building Watch Faces. Let's convert <code>timeval</code> to a <a href="https://github.com/apache/mynewt-core/blob/master/time/datetime/include/datetime/datetime.h#L31-L40"><code>clocktime</code> struct</a> format...</p>
<pre><code class="language-c">//  Convert the time from timeval format to clocktime format
struct clocktime ct;
rc = timeval_to_clocktime(&amp;tv, &amp;tz, &amp;ct);
if (rc != 0) { console_printf(&quot;Can't convert time: %d\n&quot;, rc); return 3; }
</code></pre>
<p>This produces <code>ct</code>, a <a href="https://github.com/apache/mynewt-core/blob/master/time/datetime/include/datetime/datetime.h#L31-L40"><code>clocktime</code> struct</a> that contains the date and time components: day, month, year, hours, minutes, seconds and day of week.</p>
<p>Perfect for building a Watch Face!</p>
<p>If we need the current date and time in printable <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format...</p>
<pre><code class="language-c">//  Format the clocktime time as 2020-10-04T13:20:26.839843+00:00
char buf[50];
rc = datetime_format(&amp;tv, &amp;tz, buf, sizeof(buf));
if (rc != 0) { console_printf(&quot;Can't format time: %d\n&quot;, rc); return 4; }
</code></pre>
<p>This produces the currrent date and time in <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format like...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="number">2020</span><span class="op">-</span><span class="number">10</span><span class="op">-</span><span class="number">04T13</span>:<span class="number">20</span>:<span class="number">26.839843</span><span class="op">+</span><span class="number">00</span>:<span class="number">00</span></pre></div>
<p>For our simple Watch Face in C, we'll truncate the time up to the minute...</p>
<pre><code class="language-c">//  Truncate after minute: 2020-10-04T13:20
buf[16] = 0;
</code></pre>
<p>Which looks like this...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="number">2020</span><span class="op">-</span><span class="number">10</span><span class="op">-</span><span class="number">04T13</span>:<span class="number">20</span></pre></div>
<h1 id="get-the-time-in-rust" class="section-header"><a href="#get-the-time-in-rust">7 Get the Time in Rust</a></h1>
<p>Here's how we fetch the Mynewt system time in Rust: <a href="https://github.com/lupyuen/pinetime-watchface/blob/master/src/lib.rs#L164-L190"><code>pinetime-watchface/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Get the system time</span>
<span class="kw">fn</span> <span class="ident">get_system_time</span>() <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span><span class="ident">WatchFaceTime</span><span class="op">&gt;</span> {
    <span class="comment">//  Get the system time</span>
    <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">TV</span>: <span class="ident">os</span>::<span class="ident">os_timeval</span>  <span class="op">=</span> <span class="macro">fill_zero</span><span class="macro">!</span>(<span class="ident">os</span>::<span class="ident">os_timeval</span>);
    <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">TZ</span>: <span class="ident">os</span>::<span class="ident">os_timezone</span> <span class="op">=</span> <span class="macro">fill_zero</span><span class="macro">!</span>(<span class="ident">os</span>::<span class="ident">os_timezone</span>);
    <span class="kw">let</span> <span class="ident">rc</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">os</span>::<span class="ident">os_gettimeofday</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">TV</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">TZ</span>) };
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rc</span> <span class="op">==</span> <span class="number">0</span>, <span class="string">&quot;Can&#39;t get time&quot;</span>);    

    <span class="comment">//  Convert the time</span>
    <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">CT</span>: <span class="ident">clocktime</span> <span class="op">=</span> <span class="macro">fill_zero</span><span class="macro">!</span>(<span class="ident">clocktime</span>);
    <span class="kw">let</span> <span class="ident">rc</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">timeval_to_clocktime</span>(<span class="kw-2">&amp;</span><span class="ident">TV</span>, <span class="kw-2">&amp;</span><span class="ident">TZ</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">CT</span>) };
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rc</span> <span class="op">==</span> <span class="number">0</span>, <span class="string">&quot;Can&#39;t convert time&quot;</span>);

    <span class="comment">//  Return the time</span>
    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="kw">unsafe</span> {  <span class="comment">//  Unsafe because CT is a mutable static</span>
        <span class="ident">WatchFaceTime</span> {
            <span class="ident">year</span>:        <span class="ident">CT</span>.<span class="ident">year</span> <span class="kw">as</span> <span class="ident">u16</span>,  <span class="comment">//  Year (4 digit year)</span>
            <span class="ident">month</span>:       <span class="ident">CT</span>.<span class="ident">mon</span>  <span class="kw">as</span>  <span class="ident">u8</span>,  <span class="comment">//  Month (1 - 12)</span>
            <span class="ident">day</span>:         <span class="ident">CT</span>.<span class="ident">day</span>  <span class="kw">as</span>  <span class="ident">u8</span>,  <span class="comment">//  Day (1 - 31)</span>
            <span class="ident">hour</span>:        <span class="ident">CT</span>.<span class="ident">hour</span> <span class="kw">as</span>  <span class="ident">u8</span>,  <span class="comment">//  Hour (0 - 23)</span>
            <span class="ident">minute</span>:      <span class="ident">CT</span>.<span class="ident">min</span>  <span class="kw">as</span>  <span class="ident">u8</span>,  <span class="comment">//  Minute (0 - 59)</span>
            <span class="ident">second</span>:      <span class="ident">CT</span>.<span class="ident">sec</span>  <span class="kw">as</span>  <span class="ident">u8</span>,  <span class="comment">//  Second (0 - 59)</span>
            <span class="ident">day_of_week</span>: <span class="ident">CT</span>.<span class="ident">dow</span>  <span class="kw">as</span>  <span class="ident">u8</span>,  <span class="comment">//  Day of week (0 - 6; 0 = Sunday)</span>
        }
    };
    <span class="prelude-val">Ok</span>(<span class="ident">result</span>)
}</pre></div>
<p>This produces a <a href="https://github.com/lupyuen/pinetime-watchface/blob/master/src/lib.rs#L226-L243"><code>WatchFaceTime</code> struct</a> that's defined in our <a href="https://crates.io/crates/pinetime-watchface"><code>pinetime-watchface</code> Watch Face Framework</a>.</p>
<p>Later we'll use <code>WatchFaceTime</code> and <code>pinetime-watchface</code> to create our Rust Watch Face.</p>
<h1 id="watch-face-in-c" class="section-header"><a href="#watch-face-in-c">8 Watch Face in C</a></h1>
<p>Now that we can fetch the current date and time in C, let's create a simple watch face!</p>
<p>TODO: Mynewt timer, <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/watch_face.c"><code>my_sensor_app/src/watch_face.c</code></a></p>
<p>Create the watch face...</p>
<p>Create a button...</p>
<pre><code class="language-c">/// Render a watch face. Called by main() in rust/app/src/lib.rs
int create_watch_face(void) {
    btn = lv_btn_create(lv_scr_act(), NULL);     //  Add a button the current screen
    lv_obj_set_pos(btn, 10, 10);                 //  Set its position
    lv_obj_set_size(btn, 220, 50);               //  Set its size
</code></pre>
<p>Add a label to the button...</p>
<pre><code class="language-c">    label = lv_label_create(btn, NULL);          //  Add a label to the button
    lv_label_set_text(label, &quot;Time Sync&quot;);       //  Set the label text
</code></pre>
<p>Create a callout timer...</p>
<pre><code class="language-c">    //  Set a timer to update the watch face every minute
    os_callout_init(
        &amp;watch_face_callout,   //  Timer for the watch face
        os_eventq_dflt_get(),  //  Use default event queue
        watch_face_callback,   //  Callback function for the timer
        NULL
    );
</code></pre>
<p>Trigger the timer...</p>
<pre><code class="language-c">    //  Trigger the timer in 60 seconds
    os_callout_reset(
        &amp;watch_face_callout,   //  Timer for the watch face
        OS_TICKS_PER_SEC * 60  //  Trigger timer in 60 seconds
    );
    return 0;
}
</code></pre>
<p>Update the watch face...</p>
<pre><code class="language-c">/// Update the watch face
int update_watch_face(void) {
    //  If button or label not created, quit
    if (btn == NULL || label == NULL) { return 1; }

    //  Get the system time
    struct os_timeval tv;
    struct os_timezone tz;
    int rc = os_gettimeofday(&amp;tv, &amp;tz);
    if (rc != 0) { console_printf(&quot;Can't get time: %d\n&quot;, rc); return 2; }

    //  Convert the time
    struct clocktime ct;
    rc = timeval_to_clocktime(&amp;tv, &amp;tz, &amp;ct);
    if (rc != 0) { console_printf(&quot;Can't convert time: %d\n&quot;, rc); return 3; }

    //  Format the time as 2020-10-04T13:20:26.839843+00:00
    char buf[50];
    rc = datetime_format(&amp;tv, &amp;tz, buf, sizeof(buf));
    if (rc != 0) { console_printf(&quot;Can't format time: %d\n&quot;, rc); return 4; }

    //  Truncate after minute: 2020-10-04T13:20
    buf[16] = 0;
</code></pre>
<p>Set the label...</p>
<pre><code class="language-c">    //  Set the label text
    lv_label_set_text(label, buf);
    return 0;
}
</code></pre>
<p>Callback every minute...</p>
<pre><code class="language-c">/// Timer callback that is called every minute
static void watch_face_callback(struct os_event *ev) {
    assert(ev != NULL);

    //  Update the watch face
    update_watch_face();
</code></pre>
<p>Render LVGL display...</p>
<pre><code class="language-c">    //  Render the watch face
    pinetime_lvgl_mynewt_render();
</code></pre>
<p>Set callout timer...</p>
<pre><code class="language-c">    //  Set the watch face timer
    os_callout_reset(
        &amp;watch_face_callout,   //  Timer for the watch face
        OS_TICKS_PER_SEC * 60  //  Trigger timer in 60 seconds
    );
}
</code></pre>
<h1 id="watch-face-in-rust" class="section-header"><a href="#watch-face-in-rust">9 Watch Face in Rust</a></h1>
<p>TODO: Barebones watch face, LVGL styles</p>
<p>Watch Face Framework</p>
<p><code>WatchFace</code> Trait: <a href="https://github.com/lupyuen/pinetime-watchface/blob/master/src/lib.rs#L164-L190"><code>pinetime-watchface/blob/master/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Watch Faces shall implement this trait</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">WatchFace</span> {
    <span class="doccomment">/// Create the widgets for the Watch Face</span>
    <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>
        <span class="kw">where</span> <span class="self">Self</span>: <span class="ident">core</span>::<span class="ident">marker</span>::<span class="ident">Sized</span>;  <span class="comment">//  Result type must have known size</span>

    <span class="doccomment">/// Update the widgets in the Watch Face with the current state</span>
    <span class="kw">fn</span> <span class="ident">update</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">state</span>: <span class="kw-2">&amp;</span><span class="ident">WatchFaceState</span>) <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span>;
}</pre></div>
<p>Create the widgets: <a href="https://github.com/lupyuen/barebones-watchface/blob/master/src/lib.rs#L72-L129"><code>barebones-watchface/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> <span class="ident">WatchFace</span> <span class="kw">for</span> <span class="ident">BarebonesWatchFace</span> {

    <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
    <span class="comment">//  Create Watch Face</span>

    <span class="doccomment">/// Create the widgets for the Watch Face</span>
    <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">//  Get the active screen</span>
        <span class="kw">let</span> <span class="ident">screen</span> <span class="op">=</span> <span class="ident">watchface</span>::<span class="ident">get_active_screen</span>();

        <span class="comment">//  Create the widgets</span>
        <span class="kw">let</span> <span class="ident">watch_face</span> <span class="op">=</span> <span class="self">Self</span> {
            <span class="comment">//  Create a Label for Time: &quot;00:00&quot;</span>
            <span class="ident">time_label</span>: {
                <span class="kw">let</span> <span class="ident">lbl</span> <span class="op">=</span> <span class="ident">label</span>::<span class="ident">create</span>(<span class="ident">screen</span>, <span class="ident">ptr</span>::<span class="ident">null</span>()) <span class="question-mark">?</span> ;  <span class="comment">//  `?` will terminate the function in case of error</span>
                <span class="ident">label</span>::<span class="ident">set_long_mode</span>(<span class="ident">lbl</span>, <span class="ident">label</span>::<span class="ident">LV_LABEL_LONG_BREAK</span>) <span class="question-mark">?</span> ;
                <span class="ident">label</span>::<span class="ident">set_text</span>(     <span class="ident">lbl</span>, <span class="macro">strn</span><span class="macro">!</span>(<span class="string">&quot;00:00&quot;</span>)) <span class="question-mark">?</span> ;     <span class="comment">//  strn creates a null-terminated string</span>
                <span class="ident">obj</span>::<span class="ident">set_width</span>(      <span class="ident">lbl</span>, <span class="number">240</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">set_height</span>(     <span class="ident">lbl</span>, <span class="number">200</span>) <span class="question-mark">?</span> ;
                <span class="ident">label</span>::<span class="ident">set_align</span>(    <span class="ident">lbl</span>, <span class="ident">label</span>::<span class="ident">LV_LABEL_ALIGN_CENTER</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">align</span>(          <span class="ident">lbl</span>, <span class="ident">screen</span>, <span class="ident">obj</span>::<span class="ident">LV_ALIGN_CENTER</span>, <span class="number">0</span>, <span class="op">-</span><span class="number">30</span>) <span class="question-mark">?</span> ;    
                <span class="ident">lbl</span>  <span class="comment">//  Return the label as time_label</span>
            },</pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
            <span class="comment">//  Create a Label for Date: &quot;MON 22 MAY 2020&quot;</span>
            <span class="ident">date_label</span>: {
                <span class="kw">let</span> <span class="ident">lbl</span> <span class="op">=</span> <span class="ident">label</span>::<span class="ident">create</span>(<span class="ident">screen</span>, <span class="ident">ptr</span>::<span class="ident">null</span>()) <span class="question-mark">?</span> ;
                <span class="ident">label</span>::<span class="ident">set_long_mode</span>(<span class="ident">lbl</span>, <span class="ident">label</span>::<span class="ident">LV_LABEL_LONG_BREAK</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">set_width</span>(      <span class="ident">lbl</span>, <span class="number">200</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">set_height</span>(     <span class="ident">lbl</span>, <span class="number">200</span>) <span class="question-mark">?</span> ;
                <span class="ident">label</span>::<span class="ident">set_text</span>(     <span class="ident">lbl</span>, <span class="macro">strn</span><span class="macro">!</span>(<span class="string">&quot;&quot;</span>)) <span class="question-mark">?</span> ;  <span class="comment">//  strn creates a null-terminated string</span>
                <span class="ident">label</span>::<span class="ident">set_align</span>(    <span class="ident">lbl</span>, <span class="ident">label</span>::<span class="ident">LV_LABEL_ALIGN_CENTER</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">align</span>(          <span class="ident">lbl</span>, <span class="ident">screen</span>, <span class="ident">obj</span>::<span class="ident">LV_ALIGN_CENTER</span>, <span class="number">0</span>, <span class="number">40</span>) <span class="question-mark">?</span> ;
                <span class="ident">lbl</span>  <span class="comment">//  Return the label as date_label</span>
            },</pre></div>
<p>Label for Bluetooth State...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
            <span class="comment">//  Create a Label for Bluetooth State</span>
            <span class="ident">bluetooth_label</span>: {
                <span class="kw">let</span> <span class="ident">lbl</span> <span class="op">=</span> <span class="ident">label</span>::<span class="ident">create</span>(<span class="ident">screen</span>, <span class="ident">ptr</span>::<span class="ident">null</span>()) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">set_width</span>(     <span class="ident">lbl</span>, <span class="number">50</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">set_height</span>(    <span class="ident">lbl</span>, <span class="number">80</span>) <span class="question-mark">?</span> ;
                <span class="ident">label</span>::<span class="ident">set_text</span>(    <span class="ident">lbl</span>, <span class="macro">strn</span><span class="macro">!</span>(<span class="string">&quot;&quot;</span>)) <span class="question-mark">?</span> ;  <span class="comment">//  strn creates a null-terminated string</span>
                <span class="ident">label</span>::<span class="ident">set_recolor</span>( <span class="ident">lbl</span>, <span class="bool-val">true</span>) <span class="question-mark">?</span> ;
                <span class="ident">label</span>::<span class="ident">set_align</span>(   <span class="ident">lbl</span>, <span class="ident">label</span>::<span class="ident">LV_LABEL_ALIGN_LEFT</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">align</span>(         <span class="ident">lbl</span>, <span class="ident">screen</span>, <span class="ident">obj</span>::<span class="ident">LV_ALIGN_IN_TOP_LEFT</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="question-mark">?</span> ;
                <span class="ident">lbl</span>  <span class="comment">//  Return the label as bluetooth_label</span>
            },</pre></div>
<p>Label for Power Indicator...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
            <span class="comment">//  Create a Label for Power Indicator</span>
            <span class="ident">power_label</span>: {
                <span class="kw">let</span> <span class="ident">lbl</span> <span class="op">=</span> <span class="ident">label</span>::<span class="ident">create</span>(<span class="ident">screen</span>, <span class="ident">ptr</span>::<span class="ident">null</span>()) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">set_width</span>(    <span class="ident">lbl</span>, <span class="number">80</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">set_height</span>(   <span class="ident">lbl</span>, <span class="number">20</span>) <span class="question-mark">?</span> ;
                <span class="ident">label</span>::<span class="ident">set_text</span>(   <span class="ident">lbl</span>, <span class="macro">strn</span><span class="macro">!</span>(<span class="string">&quot;&quot;</span>)) <span class="question-mark">?</span> ;  <span class="comment">//  strn creates a null-terminated string</span>
                <span class="ident">label</span>::<span class="ident">set_recolor</span>(<span class="ident">lbl</span>, <span class="bool-val">true</span>) <span class="question-mark">?</span> ;
                <span class="ident">label</span>::<span class="ident">set_align</span>(  <span class="ident">lbl</span>, <span class="ident">label</span>::<span class="ident">LV_LABEL_ALIGN_RIGHT</span>) <span class="question-mark">?</span> ;
                <span class="ident">obj</span>::<span class="ident">align</span>(        <span class="ident">lbl</span>, <span class="ident">screen</span>, <span class="ident">obj</span>::<span class="ident">LV_ALIGN_IN_TOP_RIGHT</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="question-mark">?</span> ;
                <span class="ident">lbl</span>  <span class="comment">//  Return the label as power_label</span>
            },
        };
        <span class="comment">//  Return the watch face</span>
        <span class="prelude-val">Ok</span>(<span class="ident">watch_face</span>)
    }</pre></div>
<p>Update widgets...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> <span class="ident">WatchFace</span> <span class="kw">for</span> <span class="ident">BarebonesWatchFace</span> {

    <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
    <span class="comment">//  Update Watch Face</span>

    <span class="doccomment">/// Update the widgets in the Watch Face with the current state</span>
    <span class="kw">fn</span> <span class="ident">update</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">state</span>: <span class="kw-2">&amp;</span><span class="ident">WatchFaceState</span>) <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="comment">//  Populate the Time and Date Labels</span>
        <span class="self">self</span>.<span class="ident">update_date_time</span>(<span class="ident">state</span>) <span class="question-mark">?</span> ;

        <span class="comment">//  Populate the Bluetooth Label</span>
        <span class="self">self</span>.<span class="ident">update_bluetooth</span>(<span class="ident">state</span>) <span class="question-mark">?</span> ;

        <span class="comment">//  Populate the Power Label</span>
        <span class="self">self</span>.<span class="ident">update_power</span>(<span class="ident">state</span>) <span class="question-mark">?</span> ;
        <span class="prelude-val">Ok</span>(())
    }    </pre></div>
<p>Populate time and date widgets...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> <span class="ident">BarebonesWatchFace</span> {

    <span class="doccomment">/// Populate the Time and Date Labels with the time and date</span>
    <span class="kw">fn</span> <span class="ident">update_date_time</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">state</span>: <span class="kw-2">&amp;</span><span class="ident">WatchFaceState</span>) <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="comment">//  Create a string buffer to format the time</span>
        <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">TIME_BUF</span>: <span class="ident">String</span> <span class="op">=</span> <span class="ident">new_string</span>();

        <span class="comment">//  Format the time as &quot;12:34&quot; and set the label</span>
        <span class="kw">unsafe</span> {                  <span class="comment">//  Unsafe because TIME_BUF is a mutable static</span>
            <span class="ident">TIME_BUF</span>.<span class="ident">clear</span>();     <span class="comment">//  Erase the buffer</span>

            <span class="macro">write</span><span class="macro">!</span>(
                <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">TIME_BUF</span>,    <span class="comment">//  Write the formatted text</span>
                <span class="string">&quot;{:02}:{:02}\0&quot;</span>,  <span class="comment">//  Must terminate Rust strings with null</span>
                <span class="ident">state</span>.<span class="ident">time</span>.<span class="ident">hour</span>,
                <span class="ident">state</span>.<span class="ident">time</span>.<span class="ident">minute</span>
            ).<span class="ident">expect</span>(<span class="string">&quot;time fail&quot;</span>);

            <span class="ident">label</span>::<span class="ident">set_text</span>(      <span class="comment">//  Set the label</span>
                <span class="self">self</span>.<span class="ident">time_label</span>, 
                <span class="kw-2">&amp;</span><span class="ident">to_strn</span>(<span class="kw-2">&amp;</span><span class="ident">TIME_BUF</span>)
            ) <span class="question-mark">?</span> ;
        }

        <span class="comment">//  Get the short day name and short month name</span>
        <span class="kw">let</span> <span class="ident">day</span>   <span class="op">=</span> <span class="ident">get_day_name</span>(<span class="kw-2">&amp;</span><span class="ident">state</span>.<span class="ident">time</span>);
        <span class="kw">let</span> <span class="ident">month</span> <span class="op">=</span> <span class="ident">get_month_name</span>(<span class="kw-2">&amp;</span><span class="ident">state</span>.<span class="ident">time</span>);

        <span class="comment">//  Create a string buffer to format the date</span>
        <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">DATE_BUF</span>: <span class="ident">String</span> <span class="op">=</span> <span class="ident">new_string</span>();
        
        <span class="comment">//  Format the date as &quot;MON 22 MAY 2020&quot; and set the label</span>
        <span class="kw">unsafe</span> {                    <span class="comment">//  Unsafe because DATE_BUF is a mutable static</span>
            <span class="ident">DATE_BUF</span>.<span class="ident">clear</span>();       <span class="comment">//  Erase the buffer</span>

            <span class="macro">write</span><span class="macro">!</span>(
                <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">DATE_BUF</span>,      <span class="comment">//  Write the formatted text</span>
                <span class="string">&quot;{} {} {} {}\n\0&quot;</span>,  <span class="comment">//  Must terminate Rust strings with null</span>
                <span class="ident">day</span>,
                <span class="ident">state</span>.<span class="ident">time</span>.<span class="ident">day</span>,
                <span class="ident">month</span>,
                <span class="ident">state</span>.<span class="ident">time</span>.<span class="ident">year</span>
            ).<span class="ident">expect</span>(<span class="string">&quot;date fail&quot;</span>);

            <span class="ident">label</span>::<span class="ident">set_text</span>(        <span class="comment">//  Set the label</span>
                <span class="self">self</span>.<span class="ident">date_label</span>, 
                <span class="kw-2">&amp;</span><span class="ident">to_strn</span>(<span class="kw-2">&amp;</span><span class="ident">DATE_BUF</span>)
            ) <span class="question-mark">?</span> ;
        }
        <span class="prelude-val">Ok</span>(())
    }    </pre></div>
<p>Update Bluetooth state...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> <span class="ident">BarebonesWatchFace</span> {
    <span class="doccomment">/// Populate the Bluetooth Label with the Bluetooth State (Bluetooth Icon)</span>
    <span class="kw">fn</span> <span class="ident">update_bluetooth</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">state</span>: <span class="kw-2">&amp;</span><span class="ident">WatchFaceState</span>) <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">state</span>.<span class="ident">bluetooth</span> <span class="op">==</span> <span class="ident">BluetoothState</span>::<span class="ident">BLUETOOTH_STATE_DISCONNECTED</span> {
            <span class="comment">//  If Bluetooth is disconnected, leave the label empty</span>
            <span class="ident">label</span>::<span class="ident">set_text</span>(
                <span class="self">self</span>.<span class="ident">bluetooth_label</span>, 
                <span class="macro">strn</span><span class="macro">!</span>(<span class="string">&quot;&quot;</span>)
            ) <span class="question-mark">?</span> ;
        } <span class="kw">else</span> {
            <span class="comment">//  Compute the color of the Bluetooth icon</span>
            <span class="kw">let</span> <span class="ident">color</span> <span class="op">=</span> 
                <span class="kw">match</span> <span class="kw-2">&amp;</span><span class="ident">state</span>.<span class="ident">bluetooth</span> {
                    <span class="ident">BluetoothState</span>::<span class="ident">BLUETOOTH_STATE_INACTIVE</span>     <span class="op">=&gt;</span> <span class="string">&quot;#000000&quot;</span>,  <span class="comment">//  Black</span>
                    <span class="ident">BluetoothState</span>::<span class="ident">BLUETOOTH_STATE_ADVERTISING</span>  <span class="op">=&gt;</span> <span class="string">&quot;#5794f2&quot;</span>,  <span class="comment">//  Blue</span>
                    <span class="ident">BluetoothState</span>::<span class="ident">BLUETOOTH_STATE_DISCONNECTED</span> <span class="op">=&gt;</span> <span class="string">&quot;#f2495c&quot;</span>,  <span class="comment">//  Red</span>
                    <span class="ident">BluetoothState</span>::<span class="ident">BLUETOOTH_STATE_CONNECTED</span>    <span class="op">=&gt;</span> <span class="string">&quot;#37872d&quot;</span>,  <span class="comment">//  Dark Green</span>
                };

                <span class="comment">//  Create a string buffer to format the Bluetooth status</span>
            <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">BLUETOOTH_STATUS</span>: <span class="ident">String</span> <span class="op">=</span> <span class="ident">new_string</span>();

            <span class="comment">//  Format the Bluetooth status and set the label</span>
            <span class="kw">unsafe</span> {                       <span class="comment">//  Unsafe because BLUETOOTH_STATUS is a mutable static</span>
                <span class="ident">BLUETOOTH_STATUS</span>.<span class="ident">clear</span>();  <span class="comment">//  Erase the buffer</span>

                <span class="macro">write</span><span class="macro">!</span>(
                    <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BLUETOOTH_STATUS</span>, <span class="comment">//  Write the formatted text</span>
                    <span class="string">&quot;{} \u{F293}#\0&quot;</span>,      <span class="comment">//  LV_SYMBOL_BLUETOOTH. Must terminate Rust strings with null.</span>
                    <span class="ident">color</span>
                ).<span class="ident">expect</span>(<span class="string">&quot;bt fail&quot;</span>);

                <span class="ident">label</span>::<span class="ident">set_text</span>(           <span class="comment">//  Set the label</span>
                    <span class="self">self</span>.<span class="ident">bluetooth_label</span>, 
                    <span class="kw-2">&amp;</span><span class="ident">to_strn</span>(<span class="kw-2">&amp;</span><span class="ident">BLUETOOTH_STATUS</span>)
                ) <span class="question-mark">?</span> ;
            }
        }
        <span class="prelude-val">Ok</span>(())
    }</pre></div>
<p>Update power indicator...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> <span class="ident">BarebonesWatchFace</span> {
    <span class="doccomment">/// Populate the Power Label with the Power Indicator (Charging &amp; Battery)</span>
    <span class="kw">fn</span> <span class="ident">update_power</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">state</span>: <span class="kw-2">&amp;</span><span class="ident">WatchFaceState</span>) <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="comment">//  Get the active screen</span>
        <span class="kw">let</span> <span class="ident">screen</span> <span class="op">=</span> <span class="ident">watchface</span>::<span class="ident">get_active_screen</span>();

        <span class="comment">//  Compute the percentage power</span>
        <span class="kw">let</span> <span class="ident">percentage</span> <span class="op">=</span> <span class="ident">convert_battery_voltage</span>(<span class="ident">state</span>.<span class="ident">millivolts</span>);

        <span class="comment">//  Compute the colour for the charging symbol</span>
        <span class="kw">let</span> <span class="ident">color</span> <span class="op">=</span>                                                     <span class="comment">//  Charging color</span>
            <span class="kw">if</span> <span class="ident">percentage</span> <span class="op">&lt;=</span> <span class="number">20</span>                        { <span class="string">&quot;#f2495c&quot;</span> }    <span class="comment">//  Low Battery</span>
            <span class="kw">else</span> <span class="kw">if</span> <span class="ident">state</span>.<span class="ident">powered</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>(<span class="ident">state</span>.<span class="ident">charging</span>) { <span class="string">&quot;#73bf69&quot;</span> }    <span class="comment">//  Full Battery</span>
            <span class="kw">else</span>                                       { <span class="string">&quot;#fade2a&quot;</span> };   <span class="comment">//  Mid Battery</span>

        <span class="kw">let</span> <span class="ident">symbol</span> <span class="op">=</span>                         <span class="comment">//  Charging symbol</span>
            <span class="kw">if</span> <span class="ident">state</span>.<span class="ident">powered</span> { <span class="string">&quot;\u{F0E7}&quot;</span> }  <span class="comment">//  LV_SYMBOL_CHARGE</span>
            <span class="kw">else</span>             { <span class="string">&quot; &quot;</span> };

        <span class="comment">//  Create a string buffer to format the Power Indicator</span>
        <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">BATTERY_STATUS</span>: <span class="ident">String</span> <span class="op">=</span> <span class="ident">new_string</span>();

        <span class="comment">//  Format thePower Indicator and set the label</span>
        <span class="kw">unsafe</span> {                             <span class="comment">//  Unsafe because BATTERY_STATUS is a mutable static</span>
            <span class="ident">BATTERY_STATUS</span>.<span class="ident">clear</span>();          <span class="comment">//  Erase the buffer</span>

            <span class="macro">write</span><span class="macro">!</span>(
                <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BATTERY_STATUS</span>, 
                <span class="string">&quot;{} {}%{}#\nRUST ({}mV)\0&quot;</span>,  <span class="comment">//  Must terminate Rust strings with null</span>
                <span class="ident">color</span>,
                <span class="ident">percentage</span>,
                <span class="ident">symbol</span>,
                <span class="ident">state</span>.<span class="ident">millivolts</span>
            ).<span class="ident">expect</span>(<span class="string">&quot;batt fail&quot;</span>);

            <span class="ident">label</span>::<span class="ident">set_text</span>(
                <span class="self">self</span>.<span class="ident">power_label</span>, 
                <span class="kw-2">&amp;</span><span class="ident">to_strn</span>(<span class="kw-2">&amp;</span><span class="ident">BATTERY_STATUS</span>)
            ) <span class="question-mark">?</span> ; 
        }
        <span class="ident">obj</span>::<span class="ident">align</span>(
            <span class="self">self</span>.<span class="ident">power_label</span>, <span class="ident">screen</span>, 
            <span class="ident">obj</span>::<span class="ident">LV_ALIGN_IN_TOP_RIGHT</span>, <span class="number">0</span>, <span class="number">0</span>
        ) <span class="question-mark">?</span> ;
        <span class="prelude-val">Ok</span>(())
    }</pre></div>
<p>Watch Face Framework in <a href="https://github.com/lupyuen/pinetime-watchface/blob/master/src/lib.rs"><code>pinetime-watchface/blob/master/src/lib.rs</code></a></p>
<p>Start the watch face...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Start rendering the watch face every minute</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">start_watch_face</span>(<span class="ident">update_watch_face</span>: <span class="ident">UpdateWatchFace</span>) <span class="op">-&gt;</span> <span class="ident">MynewtResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="ident">console</span>::<span class="ident">print</span>(<span class="string">&quot;Init Rust watch face...\n&quot;</span>); <span class="ident">console</span>::<span class="ident">flush</span>();

    <span class="comment">//  Save the callback for updating the watch face</span>
    <span class="kw">unsafe</span> { <span class="ident">UPDATE_WATCH_FACE</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">update_watch_face</span>); }

    <span class="comment">//  Get active screen from LVGL</span>
    <span class="kw">let</span> <span class="ident">screen</span> <span class="op">=</span> <span class="ident">get_active_screen</span>();

    <span class="comment">//  Allow touch events</span>
    <span class="ident">obj</span>::<span class="ident">set_click</span>(<span class="ident">screen</span>, <span class="bool-val">true</span>) <span class="question-mark">?</span> ;

    <span class="comment">//  Render the watch face</span>
    <span class="kw">let</span> <span class="ident">rc</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">pinetime_lvgl_mynewt_render</span>() };
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rc</span> <span class="op">==</span> <span class="number">0</span>, <span class="string">&quot;LVGL render fail&quot;</span>);    

    <span class="comment">//  Set a timer to update the watch face every minute</span>
    <span class="kw">unsafe</span> {  <span class="comment">//  Unsafe because os_callout_init is a Mynewt C function</span>
        <span class="ident">os</span>::<span class="ident">os_callout_init</span>(
            <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">WATCH_FACE_CALLOUT</span>,         <span class="comment">//  Timer for the watch face</span>
            <span class="ident">os</span>::<span class="ident">eventq_dflt_get</span>().<span class="ident">unwrap</span>(),  <span class="comment">//  Use default event queue</span>
            <span class="prelude-val">Some</span>(<span class="ident">watch_face_callback</span>),       <span class="comment">//  Callback function for the timer</span>
            <span class="ident">ptr</span>::<span class="ident">null_mut</span>()                  <span class="comment">//  No argument</span>
        );    
    }

    <span class="comment">//  Trigger the watch face timer in 60 seconds</span>
    <span class="kw">let</span> <span class="ident">rc</span> <span class="op">=</span> <span class="kw">unsafe</span> {  <span class="comment">//  Unsafe because os_callout_reset is a Mynewt C function</span>
        <span class="ident">os</span>::<span class="ident">os_callout_reset</span>(
            <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">WATCH_FACE_CALLOUT</span>,   <span class="comment">//  Timer for the watch face</span>
            <span class="ident">os</span>::<span class="ident">OS_TICKS_PER_SEC</span> <span class="op">*</span> <span class="number">60</span>  <span class="comment">//  Trigger timer in 60 seconds</span>
        )
    };
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rc</span> <span class="op">==</span> <span class="number">0</span>, <span class="string">&quot;Timer fail&quot;</span>);
    <span class="prelude-val">Ok</span>(())
}</pre></div>
<p>Update the watch face every minute...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Timer callback that is called every minute</span>
<span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">watch_face_callback</span>(<span class="ident">_ev</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">os</span>::<span class="ident">os_event</span>) {
    <span class="ident">console</span>::<span class="ident">print</span>(<span class="string">&quot;Update Rust watch face...\n&quot;</span>); <span class="ident">console</span>::<span class="ident">flush</span>();
    
    <span class="comment">//  If there is no callback, fail.</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="kw">unsafe</span> { <span class="ident">UPDATE_WATCH_FACE</span>.<span class="ident">is_some</span>() }, <span class="string">&quot;Update watch face missing&quot;</span>);

    <span class="comment">//  Get the system time    </span>
    <span class="kw">let</span> <span class="ident">time</span> <span class="op">=</span> <span class="ident">get_system_time</span>()
        .<span class="ident">expect</span>(<span class="string">&quot;Can&#39;t get system time&quot;</span>);

    <span class="comment">//  Compose the watch face state</span>
    <span class="kw">let</span> <span class="ident">state</span> <span class="op">=</span> <span class="ident">WatchFaceState</span> {
        <span class="ident">time</span>,
        <span class="ident">millivolts</span>: <span class="number">0</span>,     <span class="comment">//  TODO: Get current voltage</span>
        <span class="ident">charging</span>:   <span class="bool-val">true</span>,  <span class="comment">//  TODO: Get charging status</span>
        <span class="ident">powered</span>:    <span class="bool-val">true</span>,  <span class="comment">//  TODO: Get powered status</span>
        <span class="ident">bluetooth</span>:  <span class="ident">BluetoothState</span>::<span class="ident">BLUETOOTH_STATE_CONNECTED</span>,  <span class="comment">//  TODO: Get BLE state</span>
    };

    <span class="comment">//  Update the watch face</span>
    <span class="kw">unsafe</span> {  <span class="comment">//  Unsafe because WATCH_FACE is a mutable static</span>
        <span class="ident">UPDATE_WATCH_FACE</span>.<span class="ident">unwrap</span>()(<span class="kw-2">&amp;</span><span class="ident">state</span>)
            .<span class="ident">expect</span>(<span class="string">&quot;Update Watch Face fail&quot;</span>);
    }

    <span class="comment">//  Render the watch face</span>
    <span class="kw">let</span> <span class="ident">rc</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">pinetime_lvgl_mynewt_render</span>() };
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rc</span> <span class="op">==</span> <span class="number">0</span>, <span class="string">&quot;LVGL render fail&quot;</span>);    

    <span class="comment">//  Trigger the watch face timer in 60 seconds</span>
    <span class="kw">let</span> <span class="ident">rc</span> <span class="op">=</span> <span class="kw">unsafe</span> {  <span class="comment">//  Unsafe because os_callout_reset is a Mynewt C function</span>
        <span class="ident">os</span>::<span class="ident">os_callout_reset</span>(
            <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">WATCH_FACE_CALLOUT</span>,   <span class="comment">//  Timer for the watch face</span>
            <span class="ident">os</span>::<span class="ident">OS_TICKS_PER_SEC</span> <span class="op">*</span> <span class="number">60</span>  <span class="comment">//  Trigger timer in 60 seconds</span>
        )
    };
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rc</span> <span class="op">==</span> <span class="number">0</span>, <span class="string">&quot;Timer fail&quot;</span>);
}</pre></div>
<h1 id="porting-lvgl-to-mynewt" class="section-header"><a href="#porting-lvgl-to-mynewt">10 Porting LVGL to Mynewt</a></h1>
<p>TODO: SPI Driver for ST7789 Display Controller, <a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt"><code>pinetime_lvgl_mynewt</code></a></p>
<p>Located at <code>libs/pinetime_lvgl_mynewt</code></p>
<p><a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt/blob/master/src/pinetime/lvgl.c"><code>src/pinetime/lvgl.c</code></a></p>
<pre><code class="language-c">/// Init the LVGL library. Called by sysinit() during startup, defined in pkg.yml.
void pinetime_lvgl_mynewt_init(void) {    
    console_printf(&quot;Init LVGL...\n&quot;); console_flush();
    assert(pinetime_lvgl_mynewt_started == false);

    //  Init the display controller
    int rc = pinetime_lvgl_mynewt_init_display(); assert(rc == 0);

    //  Init the LVGL display
    lv_init();
    lv_port_disp_init();
    pinetime_lvgl_mynewt_started = true;
}

/// Render the LVGL display
int pinetime_lvgl_mynewt_render(void) {
    console_printf(&quot;Render LVGL display...\n&quot;); console_flush();
    //  Must tick at least 100 milliseconds to force LVGL to update display
    lv_tick_inc(100);
    //  LVGL will flush our display driver
    lv_task_handler();
    return 0;
}
</code></pre>
<p>Display Driver for ST7789: <a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt/blob/master/src/pinetime/lv_port_disp.c"><code>src/pinetime/lv_port_disp.c</code></a></p>
<pre><code class="language-c">/// Flush the content of the internal buffer the specific area on the display
static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p) {
    //  Validate parameters
    assert(area-&gt;x2 &gt;= area-&gt;x1);
    assert(area-&gt;y2 &gt;= area-&gt;y1);

    //  Set the ST7789 display window
    pinetime_lvgl_mynewt_set_window(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2);

    //  Write Pixels (RAMWR): st7735_lcd::draw() → set_pixel()
    int len = 
        ((area-&gt;x2 - area-&gt;x1) + 1) *  //  Width
        ((area-&gt;y2 - area-&gt;y1) + 1) *  //  Height
        2;                             //  2 bytes per pixel
    pinetime_lvgl_mynewt_write_command(RAMWR, NULL, 0);
    pinetime_lvgl_mynewt_write_data((const uint8_t *) color_p, len);

    //  IMPORTANT!!! Inform the graphics library that you are ready with the flushing
    lv_disp_flush_ready(disp_drv);
}
</code></pre>
<p><a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt/blob/master/src/pinetime/display.c"><code>src/pinetime/display.c</code></a></p>
<pre><code class="language-c">/// Set the ST7789 display window to the coordinates (left, top), (right, bottom)
int pinetime_lvgl_mynewt_set_window(uint8_t left, uint8_t top, uint8_t right, uint8_t bottom) {
    assert(left &lt; COL_COUNT &amp;&amp; right &lt; COL_COUNT &amp;&amp; top &lt; ROW_COUNT &amp;&amp; bottom &lt; ROW_COUNT);
    assert(left &lt;= right);
    assert(top &lt;= bottom);
    //  Set Address Window Columns (CASET): st7735_lcd::draw() → set_pixel() → set_address_window()
    int rc = pinetime_lvgl_mynewt_write_command(CASET, NULL, 0); assert(rc == 0);
    uint8_t col_para[4] = { 0x00, left, 0x00, right };
    rc = pinetime_lvgl_mynewt_write_data(col_para, 4); assert(rc == 0);

    //  Set Address Window Rows (RASET): st7735_lcd::draw() → set_pixel() → set_address_window()
    rc = pinetime_lvgl_mynewt_write_command(RASET, NULL, 0); assert(rc == 0);
    uint8_t row_para[4] = { 0x00, top, 0x00, bottom };
    rc = pinetime_lvgl_mynewt_write_data(row_para, 4); assert(rc == 0);
    return 0;
}
</code></pre>
<pre><code class="language-c">/// Transmit ST7789 command
int pinetime_lvgl_mynewt_write_command(uint8_t command, const uint8_t *params, uint16_t len) {
    hal_gpio_write(DISPLAY_DC, 0);
    int rc = transmit_spi(&amp;command, 1);
    assert(rc == 0);
    if (params != NULL &amp;&amp; len &gt; 0) {
        rc = pinetime_lvgl_mynewt_write_data(params, len);
        assert(rc == 0);
    }
    return 0;
}

/// Transmit ST7789 data
int pinetime_lvgl_mynewt_write_data(const uint8_t *data, uint16_t len) {
    hal_gpio_write(DISPLAY_DC, 1);
    transmit_spi(data, len);
    return 0;
}
</code></pre>
<h1 id="rust-wrapper-for-lvgl" class="section-header"><a href="#rust-wrapper-for-lvgl">11 Rust Wrapper for LVGL</a></h1>
<p>TODO: Bindgen, Safe Wrapper Proc Macro, <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/rust/lvgl"><code>rust/lvgl</code></a></p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">12 What's Next</a></h1>
<p>TODO: Bluetooth Time Sync, Rust Watch Faces and LVGL were developed and tested with Remote PineTime</p>
<p><a href="https://lupyuen.github.io">Check out my PineTime articles</a></p>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>

    
</body>
</html>